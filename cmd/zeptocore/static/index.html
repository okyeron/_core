<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>*core load</title>
    <link rel="stylesheet" href="/static/style.css">
</head>

<body>
    <div id="app" v-cloak>
        <header>
            <h1 style="margin:0; padding:0;"><a
                    :href="window.location.protocol+'//'+window.location.host + title + '/'">*core{{title}}</a></h1>
            <div class="progress-bar" :style="{ width: progressBarWidth }"></div>
        </header>
        <main>
            <div class="banks-selector">
                <ul>
                    <li v-for="(bank, index) in banks" :key="index" @click="selectBank(index)"
                        :class="{ 'selected': index === selectedBank }">
                        <span class="mobile-bank-label" v-if="isMobile"></span>
                        <span class="desktop-bank-label" v-else></span>
                    </li>
                </ul>
            </div>


            <div class="content-area">
                <div v-if="!isMain">
                    <h2 style="margin-bottom:0; padding-left:1rem;">Bank {{ selectedBank + 1 }}
                    </h2>
                </div>


                <div v-if="isMain" class="help-banner">
                    <h2>*core load</h2>
                    <p>
                        This tool lets you easily organize files for using on *core devices.
                    </p>
                    <p v-if="previousPages.length>0">
                        Some previous pages:
                        <span v-for="link in previousPages"><a
                                :href="window.location.protocol+'//'+window.location.host +'/'+ link + '/'">{{link}}</a>&nbsp;</span>
                    </p>
                    <p>
                        Some new pages:
                        <span v-for="link in randomPages"><a
                                :href="window.location.protocol+'//'+window.location.host +'/'+ link + '/'">{{link}}</a>&nbsp;</span>

                    </p>
                </div>

                <div class=" file-uploader" v-if="!disconnected && !isMain">
                    <!-- Add file input for selecting files -->
                    <input type="file" id="fileInput" @change="handleFileInputChange" multiple style="display: none">
                    <div class="drop-area" @drop="handleDrop" @dragover.prevent @click="openFileInput">
                        Drop your files here or click to select
                    </div>
                </div>
                <div v-if="disconnected && !isMain" style="text-align: center;">
                    <span class="loader"></span>
                </div>

                <div class="file-list" v-if="banks[selectedBank].files.length > 0 && !disconnected">
                    <button @click="clearCurrentBank" v-if="banks[selectedBank].files.length > 0"
                        style="margin-left: 0;">Clear all</button>
                    <button @click="clearSelectedFiles" v-if="selectedFiles.length > 0" style="margin-left: 0;">Clear
                        Selected</button>
                    <button @click="mergeSelectedFiles" v-if="selectedFiles.length > 0" style="margin-left: 0;">Merge
                        Selected Files</button>
                    <ul>
                        <li v-for="(file, fileIndex) in banks[selectedBank].files" :key="fileIndex"
                            @click="showFileDetails(fileIndex)" :class="{ 'selected': isSelected(fileIndex) }"
                            :data-file-number="fileIndex + 1">
                            {{ file.Filename }}
                        </li>
                    </ul>
                </div>

                <div class="file-details" v-if="selectedFile!=null && !disconnected">
                    <p style="margin-top:0;
                    padding: 0.5rem;
                    text-align: left;">{{ banks[selectedBank].files[selectedFile].Filename }} ({{
                        banks[selectedBank].files[selectedFile].SliceStart.length }} slices)</p>
                    <!-- <p><strong>Name:</strong> {{ banks[selectedBank].files[selectedFile].Filename }}</p>
                    <p><strong>Duration:</strong> {{ banks[selectedBank].files[selectedFile].Duration }} seconds</p> -->

                    <button @click="removeSelectedFile" style="margin-left:0;">Remove current</button>
                    <button @click="removeSelectedFiles" v-if="selectedFiles.length > 0">Remove Selected</button>
                    <button @click="moveFileUp" :disabled="selectedFile === 0">Move Up</button>
                    <button @click="moveFileDown" :disabled="selectedFile === banks[selectedBank].files.length - 1">Move
                        Down</button>
                    <p>
                        <input type="checkbox" id="oneshot" @click="updateOneshot"
                            v-model="banks[selectedBank].files[selectedFile].OneShot">
                        <label for="oneshot">One-shot: <span
                                v-if="banks[selectedBank].files[selectedFile].OneShot">on</span>
                            <span v-else>off</span></label>
                    </p>
                    <p v-if="banks[selectedBank].files[selectedFile].OneShot">
                        <label for="spliceplayback">One-shot mode:</label>
                        <select id="spliceplayback" @click="updateSplicePlayback"
                            v-model="banks[selectedBank].files[selectedFile].SplicePlayback">
                            <option value=0>normal</option>
                            <option value=1>stop at end of splice</option>
                            <option value=2>loop back at end of splice</option>
                            <option value=3>stop at end of sample</option>
                            <option value=4>loop back at end of sample</option>
                        </select>
                    </p>

                    <p>
                        <input type="checkbox" id="tempomatch"
                            v-model="banks[selectedBank].files[selectedFile].TempoMatch">
                        <label for="tempomatch">Tempo matching: <span
                                v-if="banks[selectedBank].files[selectedFile].TempoMatch">on (changing bpm changes
                                speed)</span>
                            <span v-else>off</span></label>
                    </p>
                    <p v-if="banks[selectedBank].files[selectedFile].TempoMatch">
                        Source BPM: <input type="number" v-model="banks[selectedBank].files[selectedFile].BPM">
                    </p>
                    <div id="waveform-parent">
                        <div id="waveform"></div>
                        <p>

                            <label style="margin-left: 2em">
                                Zoom: <input type="range" min="10" max="1000" value="10" />
                            </label>
                        </p>
                        <p>
                            <button @click="deleteRegion" style="margin-left:0;">Delete selected region</button>
                            <button @click="deleteAllRegions" style="margin-left:0;">Delete all regions</button>
                        </p>
                        <p>
                            <label style="margin-left: 2em">
                                Number of regions: <input id="onsetSlices" type="number" min="1" max="128" value=16
                                    style="width:3em;" />
                            </label>
                            <button @click="createRegionsEvenly" style="margin-left:0;">Create evenly</button>
                            <button @click="createRegionsAutomatically" style="margin-left:0;">Create from
                                transients</button>
                        </p>
                    </div>
                </div>
            </div>
        </main>
        <footer>
            <form id="downloadForm" @submit.prevent="submitForm" v-if="!isMain">
                <div class="footer-row">
                    <div class="footer-item">
                        <label for=" oversampling">Oversampling:</label>
                        <select id="oversampling" v-model="oversampling">
                            <option value="1x">1x</option>
                            <option value="2x">2x</option>
                            <option value="4x">4x</option>
                        </select>
                    </div>
                    <div class="footer-item">
                        <label for="stereoMono">&nbsp;Mono/Stereo:</label>
                        <select id="stereoMono" v-model="stereoMono">
                            <option value="stereo">Stereo</option>
                            <option value="mono">Mono</option>
                        </select>
                    </div>
                    <div class="footer-item">
                        <label for="resampling">Resampling:</label>
                        <select id="resampling" v-model="resampling">
                            <option value="linear">Linear</option>
                            <option value="quadratic">Quadratic</option>
                        </select>
                    </div>

                    <div class="footer-item">
                        <div v-if="uploading">uploading</div>
                        <div v-else-if="processing">processing</div>
                        <div v-else-if="downloading">downloading</div>
                        <button type="submit" v-else>Download</button>
                    </div>
                </div>
            </form>
        </footer>

    </div>


    <script src="/static/vue.js"></script>
    <script type="module">
        import { WaveSurferG, RegionsPluginG } from "/static/waves.js";
        window.WaveSurf = WaveSurferG;
        window.RegionsPlugin = RegionsPluginG;
    </script>
    <script>
        var wsf = null;
        var wsRegions = null;
        var totalBytesUploaded = 0;
        var totalBytesRequested = 0;
        var activeRegion = null;
        var app;
        var socket;
        var randomID = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        const ccolor = 'rgba(138, 180, 215, 0.4)';
        const wavecolor = 'rgba(0, 92, 153,0.95)';

        const debounce = (callback, wait) => {
            let timeoutId = null;
            return (...args) => {
                window.clearTimeout(timeoutId);
                timeoutId = window.setTimeout(() => {
                    callback(...args);
                }, wait);
            };
        }

        // Function to read cookies
        function readCookie(name) {
            const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
            return match ? match[2] : null;
        }

        // Function to write cookies
        function writeCookie(name, value) {
            document.cookie = `${name}=${value}; path=/`;
        }

        // Function to load previousPages from cookies
        function loadPreviousPages() {
            const previousPagesString = readCookie('previousPages');
            let previousPages = previousPagesString ? JSON.parse(previousPagesString) : [];
            console.log(previousPagesString);
            console.log(previousPages);
            return Array.from(new Set(previousPages));
        }

        function saveCurrentPage() {
            let currentAddress = window.location.pathname === '/' ? '' : window.location.pathname;
            // remove preceding slash in current address
            currentAddress = currentAddress.replace(/^\//, '');
            if (currentAddress) {
                let previousPages = loadPreviousPages();
                previousPages.push(currentAddress);
                previousPages = Array.from(new Set(previousPages));
                writeCookie('previousPages', JSON.stringify(previousPages));
            }
        }

        function generateRandomWord() {
            const minLength = 5;
            const maxLength = 10;
            const vowels = 'aeiou';
            const consonants = 'bcdfghjklmnpqrstvwxyz';

            // Generate a random length between minLength and maxLength
            const length = Math.floor(Math.random() * (maxLength - minLength + 1)) + minLength;

            let word = '';

            for (let i = 0; i < length; i++) {
                // Alternate between consonants and vowels
                if (i % 2 === 0) {
                    word += consonants[Math.floor(Math.random() * consonants.length)];
                } else {
                    word += vowels[Math.floor(Math.random() * vowels.length)];
                }
            }

            return word;
        }

        const socketMessageListener = (e) => {
            data = JSON.parse(e.data);
            if (data.action == "processed") {
                console.log("processed");
                for (var i = 0; i < data.file.SliceStart.length; i++) {
                    data.file.SliceStart[i] = parseFloat(data.file.SliceStart[i].toFixed(3));
                    data.file.SliceStop[i] = parseFloat(data.file.SliceStop[i].toFixed(3));
                }
                // append data.file to bank
                app.banks[app.selectedBank].files.push(data.file);
            } else if (data.action == "onsetdetect") {
                if (wsf != null) {
                    app.deleteAllRegions();
                    const duration = wsf.getDuration();
                    for (var i = 1; i < data.sliceStart.length; i++) {
                        wsRegions.addRegion({
                            start: data.sliceStart[i - 1],
                            end: data.sliceStart[i],
                            color: ccolor,
                            drag: true,
                            resize: true,
                            loop: false,
                        });
                    }
                    wsRegions.addRegion({
                        start: data.sliceStart[data.sliceStart.length - 1],
                        end: duration,
                        color: ccolor,
                        drag: true,
                        resize: true,
                        loop: false,
                    });
                }
            } else if (data.action == "getstate") {
                var savedState = JSON.parse(data.state);
                if (savedState.banks) {
                    app.banks = savedState.banks;
                }
                console.log(app.banks[0].files[0].SliceStart);
                if (savedState.oversampling) {
                    app.oversampling = savedState.oversampling;
                }
                if (savedState.stereoMono) {
                    app.stereoMono = savedState.stereoMono;
                }
                if (savedState.selectedBank !== undefined) {
                    app.selectedBank = savedState.selectedBank;
                }
                if (savedState.selectedFile !== undefined) {
                    app.selectedFile = savedState.selectedFile;
                }
                if (app.selectedFile != null) {
                    setTimeout(() => {
                        showWaveform(app.banks[app.selectedBank].files[app.selectedFile].PathToFile,
                            app.banks[app.selectedBank].files[app.selectedFile].Duration,
                            app.banks[app.selectedBank].files[app.selectedFile].SliceStart,
                            app.banks[app.selectedBank].files[app.selectedFile].SliceStop);
                    }, 100);
                }

            } else if (data.action == "processingstart") {
                app.uploading = false;
                app.processing = true;
                app.downloading = false;
            } else if (data.action == "processingstop") {
                app.uploading = false;
                app.processing = false;
                app.downloading = true;
            } else if (data.action == "progress") {
                totalBytesUploaded += data.number;
                var maxWidth = document.getElementsByClassName("progress-bar")[0].parentElement.offsetWidth;
                app.progressBarWidth = `${Math.floor(totalBytesUploaded / totalBytesRequested * maxWidth)}px`;
                if (totalBytesUploaded >= totalBytesRequested) {
                    app.progressBarWidth = `${maxWidth}px`;
                }
            } else {
                console.log(`unknown action: ${data.action}`);
            }
        };
        const socketOpenListener = (e) => {
            console.log('Connected');
            if (!app.isMain) {
                app.disconnected = false;
                setTimeout(() => {
                    if (socket != null) {
                        socket.send(JSON.stringify({
                            action: "getstate",
                            place: window.location.pathname,
                        }));
                    }
                }, 50);

            }
        };
        const socketErrorListener = (e) => {
            console.error(e);
        }
        const socketCloseListener = (e) => {
            if (socket) {
                console.log('Disconnected.');
                app.disconnected = true;
            }
            var url = window.origin.replace("http", "ws") + '/ws?id=' + randomID + "&place=" + window.location.pathname;
            socket = new WebSocket(url);
            socket.onopen = socketOpenListener;
            socket.onmessage = socketMessageListener;
            socket.onclose = socketCloseListener;
            socket.onerror = socketErrorListener;
        };
        window.addEventListener('load', (event) => {
            // Load previousPages from cookies into the app
            app.previousPages = loadPreviousPages();

            // Save the current page address into previousPages in cookies
            saveCurrentPage();

            socketCloseListener();
        });

        app = new Vue({
            el: '#app',
            data: {
                banks: Array.from({ length: 16 }, () => ({ files: [], lastSelectedFile: null })), // Add the lastSelectedFile property
                selectedBank: 0,
                selectedFile: null,
                progressBarWidth: '0px',
                oversampling: '1x', // Default to '1x'
                stereoMono: 'mono', // Default to 'mono'
                isMobile: false, // Define isMobile variable
                downloading: false,
                processing: false,
                uploading: false,
                resampling: 'linear',
                title: window.location.pathname,
                disconnected: true,
                isMain: window.location.pathname == '/',
                previousPages: [],
                randomPages: [generateRandomWord(), generateRandomWord(), generateRandomWord()],
                selectedFiles: [], // New property to store selected files
            },
            watch: {
                // Watch for changes in app properties and save state to cookies
                banks: {
                    handler: 'saveState',
                    deep: true,
                },
                oversampling: 'saveState',
                stereoMono: 'saveState',
                selectedFile: 'saveState',
                selectedBank: 'saveState',
            },
            methods: {
                isSelected(fileIndex) {
                    return this.selectedFiles.includes(fileIndex);
                },
                mergeSelectedFiles() {
                    // organize selected files by their index
                    this.selectedFiles.sort((a, b) => (a > b) ? 1 : -1);
                    console.log('Selected Files:', this.selectedFiles.map(index => this.banks[this.selectedBank].files[index].Filename));
                    socket.send(JSON.stringify({
                        action: "mergefiles",
                        filenames: this.selectedFiles.map(index => this.banks[this.selectedBank].files[index].Filename),
                    }));

                },
                deleteAllRegions() {
                    if (wsf != null) {
                        wsf.plugins[0].regions.forEach(region => {
                            region.remove();
                        });

                        // Clear the sliceStart and sliceStop arrays in the selected file
                        app.banks[app.selectedBank].files[app.selectedFile].SliceStart = [];
                        app.banks[app.selectedBank].files[app.selectedFile].SliceStop = [];

                    }
                },
                createRegionsAutomatically() {
                    socket.send(JSON.stringify({
                        action: "onsetdetect",
                        filename: this.banks[this.selectedBank].files[this.selectedFile].Filename,
                        number: parseInt(document.getElementById("onsetSlices").value),
                    }));
                },
                createRegionsEvenly() {
                    // create regions evenly
                    this.deleteAllRegions();
                    if (wsf != null) {
                        const numRegions = parseInt(document.getElementById("onsetSlices").value);
                        const duration = wsf.getDuration();
                        const regionDuration = duration / numRegions;
                        console.log(numRegions, duration, regionDuration);
                        for (var i = 0; i < numRegions; i++) {
                            wsRegions.addRegion({
                                start: i * regionDuration,
                                end: (i + 1) * regionDuration,
                                color: ccolor,
                                drag: true,
                                resize: true,
                                loop: false,
                            });

                        }
                    }

                },
                openFileInput() {
                    // Trigger file input click when the drop area is clicked
                    document.getElementById('fileInput').click();
                },
                handleFileInputChange(event) {
                    // Handle selected files when the file input changes
                    const files = event.target.files;
                    this.progressBarWidth = '0px';
                    totalBytesUploaded = 0;
                    totalBytesRequested = 0;
                    for (var i = 0; i < files.length; i++) {
                        totalBytesRequested += files[i].size;
                    }

                    const formData = new FormData();
                    for (const file of files) {
                        formData.append('files', file);
                    }

                    // Use fetch to send a POST request to the server
                    fetch('/upload?id=' + randomID + "&place=" + window.location.pathname, {
                        method: 'POST',
                        body: formData,
                    })
                        .then(response => response.json())
                        .then(data => {
                            console.log(data.message);
                            // Optionally, you can handle the server response
                        })
                        .catch(error => {
                            console.error('Error uploading files:', error);
                        });

                    // Clear the file input value to allow selecting the same file again
                    event.target.value = null;
                },
                saveState() {
                    const savedState = {
                        banks: app.banks,
                        oversampling: app.oversampling,
                        stereoMono: app.stereoMono,
                        resampling: app.resampling,
                        selectedBank: app.selectedBank,
                        selectedFile: app.selectedFile,
                    };
                    if (socket != null) {
                        socket.send(JSON.stringify({
                            action: "updatestate",
                            place: window.location.pathname,
                            state: JSON.stringify(savedState),
                        }));
                    }
                },
                clearCurrentBank() {
                    this.banks[this.selectedBank].files = [];
                    this.banks[this.selectedBank].lastSelectedFile = null;
                    this.selectedFile = null;
                },
                clearSelectedFiles() {
                    // for each index of the seleced files, remove from the current bank
                    for (var i = 0; i < this.selectedFiles.length; i++) {
                        this.banks[this.selectedBank].files.splice(this.selectedFiles[i], 1);
                    }
                    this.selectedFiles = [];
                    this.selectedFile = null;
                },
                selectBank(index) {
                    // Save the currently selected file index in the current bank
                    this.banks[this.selectedBank].lastSelectedFile = this.selectedFile;

                    // Switch to the new bank
                    this.selectedBank = index;

                    // Set the selectedFile to the last selected file in the new bank
                    this.selectedFile = this.banks[index].lastSelectedFile;
                    if (this.selectedFile != null) {
                        setTimeout(() => {
                            showWaveform(this.banks[this.selectedBank].files[this.selectedFile].PathToFile,
                                this.banks[this.selectedBank].files[this.selectedFile].Duration,
                                this.banks[this.selectedBank].files[this.selectedFile].SliceStart,
                                this.banks[this.selectedBank].files[this.selectedFile].SliceStop);
                        }, 100);
                    }
                },
                openFileInput() {
                    // Trigger file input click when the drop area is clicked
                    document.getElementById('fileInput').click();
                },
                deleteRegion() {
                    if (activeRegion != null) {
                        activeRegion.remove();
                        activeRegion = null;
                    }
                },
                updateSplicePlayback() {
                    setTimeout(() => {
                        // convert to number 
                        this.banks[this.selectedBank].files[this.selectedFile].SplicePlayback = parseInt(this.banks[this.selectedBank].files[this.selectedFile].SplicePlayback);
                        // update the server file
                        socket.send(JSON.stringify({
                            action: "setspliceplayback",
                            filename: this.banks[this.selectedBank].files[this.selectedFile].Filename,
                            number: this.banks[this.selectedBank].files[this.selectedFile].SplicePlayback,
                        }));
                    }, 100);
                },
                updateOneshot() {
                    setTimeout(() => {
                        // update the server file
                        socket.send(JSON.stringify({
                            action: "setoneshot",
                            filename: this.banks[this.selectedBank].files[this.selectedFile].Filename,
                            boolean: this.banks[this.selectedBank].files[this.selectedFile].OneShot,
                        }));
                    }, 100);
                },
                handleDrop(event) {
                    event.preventDefault();
                    const files = event.target.files || event.dataTransfer.files;
                    this.progressBarWidth = '0%';
                    totalBytesUploaded = 0;
                    totalBytesRequested = 0;
                    for (var i = 0; i < files.length; i++) {
                        totalBytesRequested += files[i].size;
                    }

                    const formData = new FormData();
                    for (const file of files) {
                        formData.append('files', file);
                    }
                    // Use fetch to send a POST request to the server
                    fetch('/upload?id=' + randomID + "&place=" + window.location.pathname, {
                        method: 'POST',
                        body: formData,
                    })
                        .then(response => response.json())
                        .then(data => {
                            console.log(data.message);
                            // Optionally, you can handle the server response
                        })
                        .catch(error => {
                            console.error('Error uploading files:', error);
                        });
                },
                showFileDetails(fileIndex) {
                    const index = this.selectedFiles.indexOf(fileIndex);
                    if (index === -1) {
                        this.selectedFile = fileIndex;
                        this.selectedFiles.push(fileIndex); // File is not selected, so add it to the selectedFiles array
                    } else {
                        this.selectedFile = null;
                        this.selectedFiles.splice(index, 1); // File is selected, so remove it from the selectedFiles array
                    }

                    if (this.selectedFile != null) {
                        this.banks[this.selectedBank].lastSelectedFile = this.selectedFile;
                        // wait 100 milliseconds
                        setTimeout(() => {
                            showWaveform(this.banks[this.selectedBank].files[this.selectedFile].PathToFile,
                                this.banks[this.selectedBank].files[this.selectedFile].Duration,
                                this.banks[this.selectedBank].files[this.selectedFile].SliceStart,
                                this.banks[this.selectedBank].files[this.selectedFile].SliceStop);
                        }, 100);
                    }
                },
                removeSelectedFiles() {
                    // Remove selected files from the current bank
                    const updatedFiles = this.banks[this.selectedBank].files.filter((file, index) => !this.selectedFiles.includes(index));

                    // Update the files array in the current bank
                    this.$set(this.banks[this.selectedBank], 'files', updatedFiles);

                    // Clear the selected files array
                    this.selectedFiles = [];

                    // Deselect the currently selected file
                    this.selectedFile = null;
                },
                removeSelectedFile() {
                    if (this.selectedFile !== null) {
                        this.banks[this.selectedBank].files.splice(this.selectedFile, 1);
                        this.selectedFile = null;
                    }
                },
                moveFileUp() {
                    if (this.selectedFile > 0) {
                        this.swapFiles(this.selectedFile, this.selectedFile - 1);
                        this.selectedFile--;
                        this.selectedFiles = [];
                        this.selectedFiles.push(this.selectedFile);
                    }
                },
                moveFileDown() {
                    if (this.selectedFile < this.banks[this.selectedBank].files.length - 1) {
                        this.swapFiles(this.selectedFile, this.selectedFile + 1);
                        this.selectedFile++;
                        this.selectedFiles = [];
                        this.selectedFiles.push(this.selectedFile);
                    }
                },
                swapFiles(index1, index2) {
                    const temp = this.banks[this.selectedBank].files[index1];
                    this.banks[this.selectedBank].files[index1] = this.banks[this.selectedBank].files[index2];
                    this.banks[this.selectedBank].files[index2] = temp;
                },
                submitForm() {
                    app.uploading = true;
                    app.processing = false;
                    app.downloading = false;

                    // Include other options as needed
                    const formData = {
                        oversampling: this.oversampling,
                        stereoMono: this.stereoMono,
                        resampling: this.resampling,
                        banks: [],
                    };
                    for (var i = 0; i < this.banks.length; i++) {
                        const bankData = {
                            files: [],
                        };

                        for (var j = 0; j < this.banks[i].files.length; j++) {
                            // Assuming you want to push file names into the files array
                            bankData.files.push(this.banks[i].files[j].Filename);
                        }

                        // Push the bank data into the formData
                        formData.banks.push(bankData);
                    }

                    // Use fetch to send a POST request to the server
                    fetch('/download?id=' + randomID + "&place=" + window.location.pathname, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(formData),
                    })
                        .then(response => {
                            const contentDisposition = response.headers.get('Content-Disposition');
                            if (contentDisposition) {
                                const filenameMatch = /attachment; filename=(.*)/.exec(contentDisposition);
                                if (filenameMatch && filenameMatch[1]) {
                                    return { filename: filenameMatch[1], blob: response.blob() };
                                }
                            }
                            return { filename: 'output.zip', blob: response.blob() };
                        })
                        .then(({ filename, blob }) => {
                            return blob.then(actualBlob => ({ filename, actualBlob }));
                        })
                        .then(({ filename, actualBlob }) => {
                            const url = window.URL.createObjectURL(new Blob([actualBlob]));
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = filename; // Set the filename dynamically
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            window.URL.revokeObjectURL(url);
                            console.log("downloaded");
                            app.uploading = false;
                            app.processing = false;
                            app.downloading = false;

                        })
                        .catch(error => {
                            console.error('Error downloading files:', error);
                        });
                },
            },
        });


        const showWaveform = debounce(showWaveform_, 100);

        function showWaveform_(filename, duration, sliceStart, sliceEnd) {
            if (wsf != null) {
                wsf.destroy();
            }
            console.log('showWaveform', filename);
            var banksSelectWidth = document.getElementsByClassName('banks-selector')[0].clientWidth;
            var newWidth = `width:${document.getElementById('waveform-parent').parentElement.clientWidth - 50}px`;
            document.getElementById('waveform-parent').style = newWidth;
            wsf = window.WaveSurf.create({
                container: '#waveform',
                waveColor: wavecolor,
                progressColor: wavecolor,
                cursorColor: wavecolor,
                hideScrollbar: false,
                autoScroll: false,
                autoCenter: true,
                url: filename + ".mp3",
            });
            // resize whenever a zoom
            wsf.on('zoom', () => {
                console.log('zoom');
            });
            // set the width of a WaveSurfer to 100 px


            wsRegions = wsf.registerPlugin(window.RegionsPlugin.create())

            wsf.on('decode', () => {
                console.log("wsf.on('decode')");
                // Regions
                for (var i = 0; i < sliceStart.length; i++) {
                    wsRegions.addRegion({
                        start: sliceStart[i] * wsf.getDuration(),
                        end: sliceEnd[i] * wsf.getDuration(),
                        color: ccolor,
                        drag: true,
                        resize: true,
                        loop: false,
                    });
                }
                setTimeout(() => {
                }, 100);
                // fix this debounce ot take argument of the region
                const updateRegion = debounce(function (region) {
                    let regions = wsf.plugins[0].regions;
                    regions.sort((a, b) => (a.start > b.start) ? 1 : -1);
                    let sliceStart = [];
                    let sliceStop = [];
                    for (var i = 0; i < regions.length; i++) {
                        if (i == 0 || regions[i].start > regions[i - 1].start) {
                            sliceStart.push(parseFloat((regions[i].start / wsf.getDuration()).toFixed(3)));
                            sliceStop.push(parseFloat((regions[i].end / wsf.getDuration()).toFixed(3)));
                        }
                    }

                    // update locally
                    app.banks[app.selectedBank].files[app.selectedFile].SliceStart = sliceStart;
                    app.banks[app.selectedBank].files[app.selectedFile].SliceStop = sliceStop;

                    // update remotely
                    socket.send(JSON.stringify({
                        action: "setslices",
                        filename: filename,
                        sliceStart: sliceStart,
                        sliceStop: sliceStop,
                    }));
                }, 1000);
                var regionTriggers = ['region-updated', 'region-created']
                for (regionTrigger of regionTriggers) {
                    wsRegions.on(
                        regionTrigger, (region) => {
                            updateRegion(region);
                        });
                }
            });

            wsRegions.enableDragSelection({
                color: ccolor,
            })

            {
                var playing = false;
                wsRegions.on('region-in', (region) => {
                    console.log('in', region.id);
                })
                wsRegions.on('region-out', (region) => {
                    console.log('out', region.id);
                    if (activeRegion.id === region.id) {
                        wsf.pause();
                        playing = false;
                    }
                })
                wsRegions.on('region-clicked', (region, e) => {
                    e.stopPropagation() // prevent triggering a click on the waveform
                    activeRegion = region;
                    console.log(region);
                    if (playing) {
                        console.log('pausing');
                        wsf.pause();
                        playing = false;
                    } else {
                        region.play();
                        playing = true;
                        setTimeout(() => {
                            wsf.pause();
                            playing = false;
                        }, (region.end - region.start) * 960);
                    }
                    // region.setOptions({ color: randomColor() })
                })
                // Reset the active region when the user clicks anywhere in the waveform
                wsf.on('interaction', () => { activeRegion = null })
            }

            // Update the zoom level on slider change
            wsf.once('decode', () => {
                document.querySelector('input[type="range"]').oninput = (e) => {
                    const minPxPerSec = Number(e.target.value)
                    wsf.zoom(minPxPerSec)
                };
            });
        }

        window.addEventListener('load', (event) => {
            // Initialize WebSocket and other event listeners
            socketCloseListener();

            // Check if the window width is less than 768 pixels to set isMobile
            app.isMobile = window.innerWidth < 768;

            // Listen for window resize events to update isMobile
            window.addEventListener('resize', () => {
                app.isMobile = window.innerWidth < 768;
            });
        });
    </script>
</body>

</html>